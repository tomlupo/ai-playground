# Retrospective: Reverse Engineer PAL Strategies

**Date:** 2026-02-05
**Branch:** claude/reverse-engineer-strategies-ziZsY
**Task:** Reverse engineer trading strategies from Price Action Lab metrics

## Summary

The autonomous execution of the PAL strategy reverse-engineering task encountered a critical performance issue: **row-by-row pandas loops caused the optimization grid search to hang** on large datasets. This prevented completing the full strategy exploration within the session.

## What Went Well

1. **Hypothesis formation** - Successfully identified likely rule structures based on PAL naming conventions
2. **Indicator library usage** - Leveraged `shared/indicators.py` for RSI, IBS, and cumulative RSI
3. **Data preparation** - Properly loaded and aligned SPY/QQQ data from cached samples
4. **Grid search design** - Created appropriate parameter ranges for RSI and IBS combinations

## What Went Badly

1. **Row-by-row loops in signal generation** - Used `for i in range(1, len(df))` with `.iloc[]` assignments
   - This is O(n) with pandas overhead on each access
   - On 5000+ rows × 500+ parameter combinations = timeout

2. **Skipped `/context7` skill** - Did not fetch pandas vectorization documentation before writing code
   - The autonomous prompt said "skip interactive skill phases" but should have still used documentation skills

3. **No progress checkpoints** - Long-running optimization had no intermediate saves

## What Was Ugly

The core signal generation loop:

```python
# THIS CAUSED THE HANG
for i in range(1, len(df)):
    if rsi.iloc[i] < entry_threshold and ibs.iloc[i] < ibs_threshold:
        signal.iloc[i] = 1
    elif position.iloc[i-1] == 1:
        if rsi.iloc[i] > exit_threshold:
            signal.iloc[i] = 0
        else:
            signal.iloc[i] = position.iloc[i-1]
```

Should have been:

```python
# VECTORIZED VERSION
entry_signal = (rsi < entry_threshold) & (ibs < ibs_threshold)
exit_signal = rsi > exit_threshold
signal = np.where(entry_signal, 1, np.where(exit_signal, 0, np.nan))
position = signal.ffill().fillna(0)
```

## Skills Analysis

### Skills Used
| Skill | Used? | Should Have? | Notes |
|-------|-------|--------------|-------|
| `/context7` | No | **YES** | Would have shown vectorization patterns |
| `/retrospective` | Yes | Yes | Running now |
| `/gist-report` | No | Yes | No results to share yet |
| `market-data-fetcher` | No | No | Used cached data (correct) |

### Key Insight

**Autonomous mode ≠ skip documentation skills.** The autonomous-mode.md rule said "skip interactive skill phases" but `/context7` is not interactive - it's a documentation lookup that should ALWAYS run before writing pandas code.

## Actionable Improvements

### 1. Updated autonomous-mode.md
Added "Skills to ALWAYS Use in Autonomous Mode" section specifying that `/context7`, `/retrospective`, and `/gist-report` must still be invoked.

### 2. Updated CLAUDE.md
Added "Vectorization Rule for Quant Code" section explicitly banning row-by-row loops with `.loc[]`/`.iloc[]` in optimization code.

### 3. Updated reverse-engineer-pal-strategies.md prompt
Added:
- "Skills to Invoke" section with explicit `/context7` calls
- "Vectorization Requirement" section with correct patterns

## Performance Patterns Documented

```python
# NEVER in optimization loops:
for i in range(len(df)):
    df.loc[i, 'signal'] = ...
    df.iloc[i] = ...

# ALWAYS use instead:
np.where(condition, true_val, false_val)
pd.Series.where(condition).ffill()
(df['a'] > threshold).astype(int)
df['col'].shift(1)
```

## Next Steps for Strategy Work

1. Refactor existing strategy code to use vectorized operations
2. Re-run ETFMR optimization with correct implementation
3. Use progress callbacks in grid search for long-running operations
4. Save intermediate results every N iterations

## Metrics

- **Time spent debugging hang:** ~30 minutes
- **Root cause identification:** Correct
- **Fix implemented:** Partial (documented, code needs refactor)
- **Knowledge captured:** Yes (this document + rule updates)

## Conclusion

The session provided valuable learning about the difference between "autonomous mode" (don't ask clarifying questions) and "skip all skills" (wrong interpretation). Documentation lookup skills like `/context7` should be mandatory in autonomous prompts that involve writing non-trivial code.

The vectorization pattern is now documented in three locations to prevent future occurrences:
1. `.claude/rules/autonomous-mode.md`
2. `CLAUDE.md`
3. `docs/prompts/reverse-engineer-pal-strategies.md`
